var interval;
var retryCount = 0;
var configfile = "./config/default.json";
const maxRetryDelayInMs = config.get<number>('intervals.maxRetryDelayInSec') * 1000;
const periodicSendIntervalInMs = config.get<number>('intervals.periodicSendIntervalInSec') * 1000;
var objectTracker = { };








function sendOldValues() {
    for(var uuid in objectTracker) {
        var interval = periodicSendIntervalInMs;
        if (objectTracker[uuid].config.intervalSec !== undefined) {
            interval = objectTracker[uuid].config.intervalSec * 1000;
            
            // do not send old values when interval = 0
            if (interval == 0) continue;
        }
        if (objectTracker[uuid].lastSeen + interval < Date.now()) {
            objectTracker[uuid].lastSeen = Date.now();
            influxStore.sendToInflux(uuid, objectTracker[uuid].lastValue, "old");
        }
    }
}

function updateTracker(uuid, value) {
    if (objectTracker[uuid] === undefined) {
        objectTracker[uuid] = { };
        objectTracker[uuid].config = config.get('uuids')[uuid];
    }
    
    objectTracker[uuid].lastSeen = Date.now();
    objectTracker[uuid].lastValue = value;
}

loxoneConnection.on("update", update);

function update(uuid, evt) {
    if (uuid in config.get<any[]>('uuids')) {
        Logger.log_info(config.get('uuids')[uuid].measurement + ', ' + getTags(config.get('uuids')[uuid].tags) + ', value=' + limit_str(evt, 100));
        
        updateTracker(uuid, evt);
        this.influxStore.sendToInflux(uuid, evt, "ws");

    } else {
        Logger.log_debug('Ignoring event value: uuid='+uuid+', evt='+limit_str(evt, 100)+'');
    }
}

loxoneConnection.on("close", stopIntervalSending);
loxoneConnection.on("connection_error", stopIntervalSending);
loxoneConnection.on("authorized", startIntervalSending);

function stopIntervalSending() {
    clearInterval(interval);
}

function startIntervalSending() {
    interval = setInterval(function() { sendOldValues() }, 10000);
}

/*
// wire up config auto reload
if (config.get<boolean>('autoreloaduuids')) {
    log_info("Startring to watch for changes in '" + configfile + "'")
    fs.watchFile(configfile, (curr, prev) => {
        log_info("Config file changed, reloading config");

        delete require.cache[require.resolve('config')];
        config = require('config');

        log_info("Done reloading config");
    });
}*/

lox.connect();